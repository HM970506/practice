BFS 층별로 cout -> Node queue[30], int head와 tail 만들기
최솟값 구할때 count쓰지 말고 now.level +1 이용하기!

#include <iostream>
#include <cstring>
using namespace std;

struct Node
{
	char a;
};

Node queue[30];

int tail=1;
int head=0;

int main()
{
	char n;
	cin >> n;

	queue[head].a = n;

	while (head != tail)
	{
		cout << queue[head].a << " ";

		for (int x = 0; x < 10; x++)
		{
			if (map[(int)(queue[head].a - 'A')][x] == 1)
			{
				queue[tail].a = ((char)(x+'A'));
				tail++;
			}
		}
		head++;
	}


	return 0;
}

DFS 방향별로 cout -> 재귀 이용

#include <iostream>
using namespace std;

int map[15] = { 0,3,4,2,4,1,0,3 };
int index;
int target;

void DFS(int r)
{
	if (r >= 15) return;

	if(map[r]!=0) 	cout << map[r]<<" ";
	DFS(r*2);
	DFS(r * 2 + 1);
}

int main()
{
	cin >> index >> target;

	map[index] = target;

	DFS(1);
	
	return 0;
}