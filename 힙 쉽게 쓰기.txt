
struct Node
{
	int num;
};

bool operator < (Node t1, Node t2)
{
	if (t1.num > t2.num) return true;
	return false;
}

int main()
{
	int vect[5] = { 1,2,3,4,5 };
	int n = 5;

	priority_queue<Node> t;
	
	int a;
	int b;
	int sum;
	int result = 0;

	for (int x = 0; x < n; x++)
	{
		t.push({ vect[x]});
	}
	
	Node ret;

	for (int x = 0; x < n - 1; x++)
	{
		ret = t.top();
		t.pop();
		a = ret.num;

		ret = t.top();
		t.pop();
		b = ret.num;


		sum=a+b;
		result += sum;
		t.push({ sum });
	}
	
	cout << result;


	return 0;
}



#include <iostream>
#include <queue>
using namespace std;

struct Node
{
	int y;
	int x;
};
int main()
{
	int map[4][4] = {
		0,3,3,3,
		1,7,2,2,
		1,3,1,2,
		2,99,4,0 };

	int a[4][4]; //누적값

	for (int y = 0; y < 4; y++)
	{
		for (int x = 0; x < 4; x++)
		{
			a[y][x] = 99;
		}
	}
	a[3][3] = 0;

	Node b[4][4]; //방향

	int direct[2][2]= {
		1,0,
		0,1 };

	for (int y = 3; y >= 0; y--)
	{
		for (int x = 3; x >= 0; x--)
		{
			for (int z = 0; z < 2; z++)
			{

				int yy = y - direct[z][0];
				int xx = x - direct[z][1];

				if (yy >= 0 && yy < 4 && xx >= 0 && xx < 4)
				{
					int i = map[yy][xx] + a[y][x]; //누적값 채우기
					if (i < a[yy][xx])
					{
						a[yy][xx] = i; //더 작은 누적값으로 채우기
						b[yy][xx] = { direct[z][0], direct[z][1] }; //더 작았던 쪽으로방향 채우기
					}
				}
					
			}
		}
	}

	for (int y = 0; y < 4; y++)
	{
		for (int x = 0; x < 4; x++)
		{
			cout << y  << x << endl;
			y += b[y][x].y;
			x += b[y][x].x;

		}
	}


	return 0;
}